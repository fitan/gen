// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strconv"
	"strings"
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/cmd/model"
	"gorm.io/gen/field"
	"gorm.io/gen/helper"
)

func newUser(db *gorm.DB) user {
	_user := user{}

	_user.userDo.UseDB(db)
	_user.userDo.UseModel(&model.User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewField(tableName, "*")
	_user.ID = field.NewInt32(tableName, "id")
	_user.Name = field.NewString(tableName, "name")
	_user.Age = field.NewInt32(tableName, "age")
	_user.Password = field.NewString(tableName, "password")
	_user.DeletedAt = field.NewField(tableName, "deleted_at")
	_user.Title = field.NewString(tableName, "title")
	_user.IsAdult = field.NewInt32(tableName, "is_adult")
	_user.UpdatedTime = field.NewTime(tableName, "updated_time")
	_user.Pass = field.NewString(tableName, "pass")
	_user.Role = field.NewString(tableName, "role")
	_user.CreatedAt = field.NewTime(tableName, "created_at")
	_user.UpdatedAt = field.NewTime(tableName, "updated_at")
	_user.Address = field.NewString(tableName, "address")

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo

	ALL         field.Field
	ID          field.Int32
	Name        field.String
	Age         field.Int32
	Password    field.String
	DeletedAt   field.Field
	Title       field.String
	IsAdult     field.Int32
	UpdatedTime field.Time
	Pass        field.String
	Role        field.String
	CreatedAt   field.Time
	UpdatedAt   field.Time
	Address     field.String

	fieldMap map[string]field.Expr
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))

	u.ALL = field.NewField(alias, "*")
	u.ID = field.NewInt32(alias, "id")
	u.Name = field.NewString(alias, "name")
	u.Age = field.NewInt32(alias, "age")
	u.Password = field.NewString(alias, "password")
	u.DeletedAt = field.NewField(alias, "deleted_at")
	u.Title = field.NewString(alias, "title")
	u.IsAdult = field.NewInt32(alias, "is_adult")
	u.UpdatedTime = field.NewTime(alias, "updated_time")
	u.Pass = field.NewString(alias, "pass")
	u.Role = field.NewString(alias, "role")
	u.CreatedAt = field.NewTime(alias, "created_at")
	u.UpdatedAt = field.NewTime(alias, "updated_at")
	u.Address = field.NewString(alias, "address")

	u.fillFieldMap()

	return &u
}

func (u *user) GetFieldByName(fieldName string) (field.Expr, bool) {
	field, ok := u.fieldMap[fieldName]
	return field, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 13)
	u.fieldMap["id"] = u.ID
	u.fieldMap["name"] = u.Name
	u.fieldMap["age"] = u.Age
	u.fieldMap["password"] = u.Password
	u.fieldMap["deleted_at"] = u.DeletedAt
	u.fieldMap["title"] = u.Title
	u.fieldMap["is_adult"] = u.IsAdult
	u.fieldMap["updated_time"] = u.UpdatedTime
	u.fieldMap["pass"] = u.Pass
	u.fieldMap["role"] = u.Role
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["address"] = u.Address
}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	return u
}

type userDo struct{ gen.DO }

//select * from users where age>18
func (u userDo) TestSimple() (result []*model.User) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where age>18")

	_ = u.UnderlyingDB().Raw(generateSQL.String()).Find(&result)
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		name = @name and
//{{end}}
//1=1
func (u userDo) TestFor(names []string) (result *model.User, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where ")
	for _index, name := range names {
		params["nameForGenerateSQL_"+strconv.Itoa(_index)] = name
		generateSQL.WriteString(" name = @nameForGenerateSQL_" + strconv.Itoa(_index) + " and ")
	}
	generateSQL.WriteString(" 1=1")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		@@name = @value and
//{{end}}
//1=1
func (u userDo) TestForKey(names []string, name string, value string) (result *model.User, err error) {
	params := map[string]interface{}{
		"value": value,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where ")
	for _, name := range names {
		generateSQL.WriteString(u.Quote(name) + " = @value and ")
	}
	generateSQL.WriteString(" 1=1")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		{{if name !=""}}
//			name = @name or
//		{{end}}
//{{end}}
//1=2
func (u userDo) TestIfInFor(names []string, name string) (result *model.User, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where ")
	for _index, name := range names {
		if name != "" {
			params["nameForGenerateSQL_"+strconv.Itoa(_index)] = name
			generateSQL.WriteString(" name = @nameForGenerateSQL_" + strconv.Itoa(_index) + " or ")
		}
	}
	generateSQL.WriteString(" 1=2")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{if name !="" }}
//		{{for _,forName:=range names}}
//			name = @forName or
//		{{end}}
//{{end}}
//1=2
func (u userDo) TestForInIf(names []string, name string) (result *model.User, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where ")
	if name != "" {
		for _index, forName := range names {
			params["forNameForGenerateSQL_"+strconv.Itoa(_index)] = forName
			generateSQL.WriteString(" name = @forNameForGenerateSQL_" + strconv.Itoa(_index) + " or ")
		}
	}
	generateSQL.WriteString(" 1=2")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table
//	{{where}}
//		{{for _,forName:=range names}}
//			or name = @forName
//		{{end}}
//{{end}}
func (u userDo) TestForInWhere(names []string, name string, forName string) (result *model.User, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	var whereSQL0 strings.Builder
	for _index, forName := range names {
		params["forNameForWhereSQL0_"+strconv.Itoa(_index)] = forName
		whereSQL0.WriteString(" or name = @forNameForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from users
//{{where}}
//	{{for _,user :=range users}}
//		name=@user.Name
//	{{end}}
//{{end}}
func (u userDo) TestForUserList(users []model.User, name string) (result *model.User, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users ")
	var whereSQL0 strings.Builder
	for _index, user := range users {
		params["userNameForWhereSQL0_"+strconv.Itoa(_index)] = user.Name
		whereSQL0.WriteString(" name=@userNameForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from users
//{{where}}
// {{if name !="xx"}}
//		{{if name !="xx"}}
//			name=@name
//		{{end}}
//{{end}}
//{{end}}
func (u userDo) TestIfInIf(name string) (result *model.User) {
	params := map[string]interface{}{
		"name": name,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users ")
	var whereSQL0 strings.Builder
	if name != "xx" {
		if name != "xx" {
			whereSQL0.WriteString(" name=@name")
		}
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	return
}

//select * from @@table
//	{{where}}
//		{{for _,name := range names}}
//			and name=@name
//		{{end}}
//		{{for _,id:=range ids}}
//			and id=@id
//		{{end}}
//{{end}}
func (u userDo) TestMoreFor(names []string, ids []int) (result []*model.User) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	var whereSQL0 strings.Builder
	for _index, name := range names {
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" and name=@nameForWhereSQL0_" + strconv.Itoa(_index))
	}
	for _index, id := range ids {
		params["idForWhereSQL0_"+strconv.Itoa(_index)] = id
		whereSQL0.WriteString(" and id=@idForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = u.UnderlyingDB().Raw(generateSQL.String(), params).Find(&result)
	return
}

//select * from @@table
//	{{where}}
//		{{for _,name := range names}}
//			OR (name=@name
//			{{for _,id:=range ids}}
//				and id=@id
//			{{end}}
//			 and title !=@name)
//		{{end}}
//{{end}}
func (u userDo) TestMoreFor2(names []string, ids []int) (result []*model.User) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	var whereSQL0 strings.Builder
	for _index, name := range names {
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" OR (name=@nameForWhereSQL0_" + strconv.Itoa(_index))
		for _index, id := range ids {
			params["idForWhereSQL0_"+strconv.Itoa(_index)] = id
			whereSQL0.WriteString(" and id=@idForWhereSQL0_" + strconv.Itoa(_index))
		}
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" and title !=@nameForWhereSQL0_" + strconv.Itoa(_index) + ") ")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = u.UnderlyingDB().Raw(generateSQL.String(), params).Find(&result)
	return
}

//update @@table
//	{{set}}
//		{{for _,user:=range users}}
//			name=@user.Name,
//		{{end}}
//{{end}} where
func (u userDo) TestForInSet(users []model.User) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("update users")
	var setSQL0 strings.Builder
	for _index, user := range users {
		params["userNameForSetSQL0_"+strconv.Itoa(_index)] = user.Name
		setSQL0.WriteString(" name=@userNameForSetSQL0_" + strconv.Itoa(_index) + ", ")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	generateSQL.WriteString(" where")

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//insert into @@table(name,age)values
//		{{for index ,user:=range users}}
//			{{if index >0}}
//				,
//			{{end}}
//			(@user.Name,@user.Age)
//		{{end}}
func (u userDo) TestInsertMoreInfo(users []model.User) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("insert into users(name,age)values ")
	for index, user := range users {
		if index > 0 {
			generateSQL.WriteString(" , ")
		}
		params["userNameForGenerateSQL_"+strconv.Itoa(index)] = user.Name
		params["userAgeForGenerateSQL_"+strconv.Itoa(index)] = user.Age
		generateSQL.WriteString(" (@userNameForGenerateSQL_" + strconv.Itoa(index) + ",@userAgeForGenerateSQL_" + strconv.Itoa(index) + ") ")
	}

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//select * from @@table
//{{where}}
//	{{if name =="admin"}}
//		(
//		{{for index,user:=range users}}
//			{{if index !=0}}
//				and
//			{{end}}
//			name like @user.Name
//		{{end}}
//		)
//	{{else if name !="guest"}}
//		{{for index,guser:=range users}}
//			{{if index ==0}}
//				(
//			{{else}}
//				and
//			{{end}}
//			name = @guser.Name
//		{{end}}
//		)
//	{{else}}
//		name ="guest"
//	{{end}}
//{{end}}
func (u userDo) TestIfElseFor(name string, users []model.User) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	var whereSQL0 strings.Builder
	if name == "admin" {
		whereSQL0.WriteString(" ( ")
		for index, user := range users {
			if index != 0 {
				whereSQL0.WriteString(" and ")
			}
			params["userNameForWhereSQL0_"+strconv.Itoa(index)] = user.Name
			whereSQL0.WriteString(" name like @userNameForWhereSQL0_" + strconv.Itoa(index))
		}
		whereSQL0.WriteString(" ) ")
	} else if name != "guest" {
		for index, guser := range users {
			if index == 0 {
				whereSQL0.WriteString(" ( ")
			} else {
				whereSQL0.WriteString(" and ")
			}
			params["guserNameForWhereSQL0_"+strconv.Itoa(index)] = guser.Name
			whereSQL0.WriteString(" name = @guserNameForWhereSQL0_" + strconv.Itoa(index))
		}
		whereSQL0.WriteString(" ) ")
	} else {
		whereSQL0.WriteString(" name =\"guest\" ")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//Where("name=@name and age=@age")
func (u userDo) WhereFindByName(name string, col string, age int) (result *model.User, err error) {
	params := map[string]interface{}{
		"name": name,
		"age":  age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("name=@name and age=@age")

	executeSQL := u.UnderlyingDB().Where(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//Where("name=@names and age=@ages")
func (u userDo) FindByNameAndAge(names []string, ages interface{}) (result []*model.User, err error) {
	params := map[string]interface{}{
		"names": names,
		"ages":  ages,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("name=@names and age=@ages")

	executeSQL := u.UnderlyingDB().Where(generateSQL.String(), params).Find(&result)
	err = executeSQL.Error
	return
}

//sql("select id,name,age from @@table where age>18")
func (u userDo) FindBySimpleName() (result *model.User, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select id,name,age from users where age>18")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select count(*) from @@table)
func (u userDo) GetCount() (result int, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select count(*) from users")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select Birthday from @@table {{where}} id=@id{{end}})
func (u userDo) GotBirthDay(id int) (result time.Time, err error) {
	params := map[string]interface{}{
		"id": id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select Birthday from users")
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id=@id")
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select * from @@table)
func (u userDo) GetMap1() (result map[string]interface{}) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")

	result = make(map[string]interface{})
	_ = u.UnderlyingDB().Raw(generateSQL.String()).Take(result)
	return
}

//sql(insert into @@table (name,age)values(@name,@age))
func (u userDo) InsertUser(name string, age int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"age":  age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("insert into users (name,age)values(@name,@age)")

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//sql(select * from @@table
//		{{if name=="admin"}}
//			{{where}}
//				id>0
//				{{if age>18}}
//					and age>18
//				{{end}}
//			{{end}}
//		{{else if name=="root"}}
//			{{where}}
//				id>10
//			{{end}}
//	{{else if name=="hello"}}
//			{{where}}
//				id>16
//			{{end}}
//		{{else}}
//			{{where}}
//				id>50
//			{{end}}
//			{{if name=="user"}}
//				and 1=1
//			{{end}}
//			and name = admin
//		{{end}}
//	)
func (u userDo) WhereInIF(name string, id int, age int) (result *model.User, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	if name == "admin" {
		var whereSQL0 strings.Builder
		whereSQL0.WriteString(" id>0 ")
		if age > 18 {
			whereSQL0.WriteString(" and age>18 ")
		}
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)
	} else if name == "root" {
		var whereSQL1 strings.Builder
		whereSQL1.WriteString(" id>10 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL1)
	} else if name == "hello" {
		var whereSQL2 strings.Builder
		whereSQL2.WriteString(" id>16 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL2)
	} else {
		var whereSQL3 strings.Builder
		whereSQL3.WriteString(" id>50 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL3)
		if name == "user" {
			generateSQL.WriteString(" and 1=1 ")
		}
		generateSQL.WriteString(" and name = admin ")
	}

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(update @@table {{set}}{{if name!=""}}name=@name{{end}}{{end}}where id=@id)
func (u userDo) HasSet(name string, id int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"id":   id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("update users")
	var setSQL0 strings.Builder
	if name != "" {
		setSQL0.WriteString("name=@name")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	generateSQL.WriteString("where id=@id")

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//select * from @@table
//			{{if name=="aa{{where}}aa"}}
//				id=@id
//				{{if age>18 }}
//					and age=@age
//				{{else}}
//					and name="{{where}}name"
//				{{end}}
//				{{if name=="adm\nin"}}
//					and id>30
//				{{else if name=="sss"}}
//					and id>20
//				{{end}}
//			{{end}}
func (u userDo) RCE(name string, age int, id int) (result *model.User) {
	params := map[string]interface{}{
		"id":  id,
		"age": age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	if name == "aa{{where}}aa" {
		generateSQL.WriteString(" id=@id")
		if age > 18 {
			generateSQL.WriteString(" and age=@age")
		} else {
			generateSQL.WriteString(" and name=\"{{where}}name\" ")
		}
		if name == "adm\nin" {
			generateSQL.WriteString(" and id>30 ")
		} else if name == "sss" {
			generateSQL.WriteString(" and id>20 ")
		}
	}

	_ = u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	return
}

//update @@table
//	{{set}}
//		update_time=now(),
//		{{if name != ""}}
//			name=@name
//		{{end}}
//	{{end}}
//	{{where}}
//		id=@id
//	{{end}}
func (u userDo) UpdateName(name string, id int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"id":   id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("update users")
	var setSQL0 strings.Builder
	setSQL0.WriteString(" update_time=now(), ")
	if name != "" {
		setSQL0.WriteString(" name=@name")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id=@id")
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//sql(select id,name,age from @@table where name="aaax
//
//		\"xxx" and age >18
//				{{if cond1}} and id=true  {{end}}
//				{{if name != ""}}
//				and @@column=@name{{end}}
//			)
func (u userDo) FindByIDOrName(cond1 bool, id int, column string, name string) (result *model.User, err error) {
	params := map[string]interface{}{
		"name": name,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("\\\"xxx\" and age >18 ")
	if cond1 {
		generateSQL.WriteString(" and id=true ")
	}
	if name != "" {
		generateSQL.WriteString(" and " + u.Quote(column) + "=@name")
	}
	generateSQL.WriteString(" )")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table
//  {{where}}
//		  id>0
//       {{if cond}}id=@id {{end}}
//       {{   if value != ""}}or @@key=@value{{end}}
//   {{end}}
func (u userDo) FindByIDOrKey(cond bool, id int, key string, value string) (result *model.User, err error) {
	params := map[string]interface{}{
		"id":    id,
		"value": value,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users")
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id>0 ")
	if cond {
		whereSQL0.WriteString("id=@id")
	}
	if value != "" {
		whereSQL0.WriteString("or " + u.Quote(key) + "=@value")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select group_concat(name) from @@table
func (u userDo) FindNames() (result string, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select group_concat(name) from users")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where id>@id
func (u userDo) FindOne(id int) (result *model.User, err error) {
	params := map[string]interface{}{
		"id": id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where id>@id")

	executeSQL := u.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

func (u userDo) Debug() *userDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) *userDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) Clauses(conds ...clause.Expression) *userDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Not(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Order(conds ...field.Expr) *userDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) *userDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) *userDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) *userDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) *userDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) *userDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *userDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() *userDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*model.User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*model.User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Take() (*model.User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Last() (*model.User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Find() ([]*model.User, error) {
	result, err := u.DO.Find()
	return result.([]*model.User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error) {
	buf := make([]*model.User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) *userDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(field field.RelationField) *userDo {
	return u.withDO(u.DO.Joins(field))
}

func (u userDo) Preload(field field.RelationField) *userDo {
	return u.withDO(u.DO.Preload(field))
}

func (u userDo) FirstOrInit() (*model.User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FirstOrCreate() (*model.User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*model.User, count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	result, err = u.Offset(offset).Limit(limit).Find()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
