// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strconv"
	"strings"
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/cmd/model"
	"gorm.io/gen/field"
	"gorm.io/gen/helper"
)

func newPerson(db *gorm.DB) person {
	_person := person{}

	_person.personDo.UseDB(db)
	_person.personDo.UseModel(&model.Person{})

	tableName := _person.personDo.TableName()
	_person.ALL = field.NewField(tableName, "*")
	_person.ID = field.NewInt32(tableName, "id")
	_person.Name = field.NewString(tableName, "name")
	_person.Age = field.NewInt32(tableName, "age")
	_person.High = field.NewInt32(tableName, "high")
	_person.Birthday = field.NewTime(tableName, "birthday")

	_person.fillFieldMap()

	return _person
}

type person struct {
	personDo

	ALL      field.Field
	ID       field.Int32
	Name     field.String
	Age      field.Int32
	High     field.Int32
	Birthday field.Time

	fieldMap map[string]field.Expr
}

func (p person) As(alias string) *person {
	p.personDo.DO = *(p.personDo.As(alias).(*gen.DO))

	p.ALL = field.NewField(alias, "*")
	p.ID = field.NewInt32(alias, "id")
	p.Name = field.NewString(alias, "name")
	p.Age = field.NewInt32(alias, "age")
	p.High = field.NewInt32(alias, "high")
	p.Birthday = field.NewTime(alias, "birthday")

	p.fillFieldMap()

	return &p
}

func (p *person) GetFieldByName(fieldName string) (field.Expr, bool) {
	field, ok := p.fieldMap[fieldName]
	return field, ok
}

func (p *person) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 5)
	p.fieldMap["id"] = p.ID
	p.fieldMap["name"] = p.Name
	p.fieldMap["age"] = p.Age
	p.fieldMap["high"] = p.High
	p.fieldMap["birthday"] = p.Birthday
}

func (p person) clone(db *gorm.DB) person {
	p.personDo.ReplaceDB(db)
	return p
}

type personDo struct{ gen.DO }

//select * from users where age>18
func (p personDo) TestSimple() (result []*model.Person) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users where age>18")

	_ = p.UnderlyingDB().Raw(generateSQL.String()).Find(&result)
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		name = @name and
//{{end}}
//1=1
func (p personDo) TestFor(names []string) (result *model.Person, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people where ")
	for _index, name := range names {
		params["nameForGenerateSQL_"+strconv.Itoa(_index)] = name
		generateSQL.WriteString(" name = @nameForGenerateSQL_" + strconv.Itoa(_index) + " and ")
	}
	generateSQL.WriteString(" 1=1")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		@@name = @value and
//{{end}}
//1=1
func (p personDo) TestForKey(names []string, name string, value string) (result *model.Person, err error) {
	params := map[string]interface{}{
		"value": value,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people where ")
	for _, name := range names {
		generateSQL.WriteString(p.Quote(name) + " = @value and ")
	}
	generateSQL.WriteString(" 1=1")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{for _,name:=range names}}
//		{{if name !=""}}
//			name = @name or
//		{{end}}
//{{end}}
//1=2
func (p personDo) TestIfInFor(names []string, name string) (result *model.Person, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people where ")
	for _index, name := range names {
		if name != "" {
			params["nameForGenerateSQL_"+strconv.Itoa(_index)] = name
			generateSQL.WriteString(" name = @nameForGenerateSQL_" + strconv.Itoa(_index) + " or ")
		}
	}
	generateSQL.WriteString(" 1=2")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where
//	{{if name !="" }}
//		{{for _,forName:=range names}}
//			name = @forName or
//		{{end}}
//{{end}}
//1=2
func (p personDo) TestForInIf(names []string, name string) (result *model.Person, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people where ")
	if name != "" {
		for _index, forName := range names {
			params["forNameForGenerateSQL_"+strconv.Itoa(_index)] = forName
			generateSQL.WriteString(" name = @forNameForGenerateSQL_" + strconv.Itoa(_index) + " or ")
		}
	}
	generateSQL.WriteString(" 1=2")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table
//	{{where}}
//		{{for _,forName:=range names}}
//			or name = @forName
//		{{end}}
//{{end}}
func (p personDo) TestForInWhere(names []string, name string, forName string) (result *model.Person, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	var whereSQL0 strings.Builder
	for _index, forName := range names {
		params["forNameForWhereSQL0_"+strconv.Itoa(_index)] = forName
		whereSQL0.WriteString(" or name = @forNameForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from users
//{{where}}
//	{{for _,user :=range users}}
//		name=@user.Name
//	{{end}}
//{{end}}
func (p personDo) TestForUserList(users []model.Person, name string) (result *model.Person, err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users ")
	var whereSQL0 strings.Builder
	for _index, user := range users {
		params["userNameForWhereSQL0_"+strconv.Itoa(_index)] = user.Name
		whereSQL0.WriteString(" name=@userNameForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from users
//{{where}}
// {{if name !="xx"}}
//		{{if name !="xx"}}
//			name=@name
//		{{end}}
//{{end}}
//{{end}}
func (p personDo) TestIfInIf(name string) (result *model.Person) {
	params := map[string]interface{}{
		"name": name,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users ")
	var whereSQL0 strings.Builder
	if name != "xx" {
		if name != "xx" {
			whereSQL0.WriteString(" name=@name")
		}
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	return
}

//select * from @@table
//	{{where}}
//		{{for _,name := range names}}
//			and name=@name
//		{{end}}
//		{{for _,id:=range ids}}
//			and id=@id
//		{{end}}
//{{end}}
func (p personDo) TestMoreFor(names []string, ids []int) (result []*model.Person) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	var whereSQL0 strings.Builder
	for _index, name := range names {
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" and name=@nameForWhereSQL0_" + strconv.Itoa(_index))
	}
	for _index, id := range ids {
		params["idForWhereSQL0_"+strconv.Itoa(_index)] = id
		whereSQL0.WriteString(" and id=@idForWhereSQL0_" + strconv.Itoa(_index))
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = p.UnderlyingDB().Raw(generateSQL.String(), params).Find(&result)
	return
}

//select * from @@table
//	{{where}}
//		{{for _,name := range names}}
//			OR (name=@name
//			{{for _,id:=range ids}}
//				and id=@id
//			{{end}}
//			 and title !=@name)
//		{{end}}
//{{end}}
func (p personDo) TestMoreFor2(names []string, ids []int) (result []*model.Person) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	var whereSQL0 strings.Builder
	for _index, name := range names {
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" OR (name=@nameForWhereSQL0_" + strconv.Itoa(_index))
		for _index, id := range ids {
			params["idForWhereSQL0_"+strconv.Itoa(_index)] = id
			whereSQL0.WriteString(" and id=@idForWhereSQL0_" + strconv.Itoa(_index))
		}
		params["nameForWhereSQL0_"+strconv.Itoa(_index)] = name
		whereSQL0.WriteString(" and title !=@nameForWhereSQL0_" + strconv.Itoa(_index) + ") ")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	_ = p.UnderlyingDB().Raw(generateSQL.String(), params).Find(&result)
	return
}

//update @@table
//	{{set}}
//		{{for _,user:=range users}}
//			name=@user.Name,
//		{{end}}
//{{end}} where
func (p personDo) TestForInSet(users []model.Person) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("update people")
	var setSQL0 strings.Builder
	for _index, user := range users {
		params["userNameForSetSQL0_"+strconv.Itoa(_index)] = user.Name
		setSQL0.WriteString(" name=@userNameForSetSQL0_" + strconv.Itoa(_index) + ", ")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	generateSQL.WriteString(" where")

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//insert into @@table(name,age)values
//		{{for index ,user:=range users}}
//			{{if index >0}}
//				,
//			{{end}}
//			(@user.Name,@user.Age)
//		{{end}}
func (p personDo) TestInsertMoreInfo(users []model.Person) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("insert into people(name,age)values ")
	for index, user := range users {
		if index > 0 {
			generateSQL.WriteString(" , ")
		}
		params["userNameForGenerateSQL_"+strconv.Itoa(index)] = user.Name
		params["userAgeForGenerateSQL_"+strconv.Itoa(index)] = user.Age
		generateSQL.WriteString(" (@userNameForGenerateSQL_" + strconv.Itoa(index) + ",@userAgeForGenerateSQL_" + strconv.Itoa(index) + ") ")
	}

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//select * from @@table
//{{where}}
//	{{if name =="admin"}}
//		(
//		{{for index,user:=range users}}
//			{{if index !=0}}
//				and
//			{{end}}
//			name like @user.Name
//		{{end}}
//		)
//	{{else if name !="guest"}}
//		{{for index,guser:=range users}}
//			{{if index ==0}}
//				(
//			{{else}}
//				and
//			{{end}}
//			name = @guser.Name
//		{{end}}
//		)
//	{{else}}
//		name ="guest"
//	{{end}}
//{{end}}
func (p personDo) TestIfElseFor(name string, users []model.Person) (err error) {
	params := map[string]interface{}{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	var whereSQL0 strings.Builder
	if name == "admin" {
		whereSQL0.WriteString(" ( ")
		for index, user := range users {
			if index != 0 {
				whereSQL0.WriteString(" and ")
			}
			params["userNameForWhereSQL0_"+strconv.Itoa(index)] = user.Name
			whereSQL0.WriteString(" name like @userNameForWhereSQL0_" + strconv.Itoa(index))
		}
		whereSQL0.WriteString(" ) ")
	} else if name != "guest" {
		for index, guser := range users {
			if index == 0 {
				whereSQL0.WriteString(" ( ")
			} else {
				whereSQL0.WriteString(" and ")
			}
			params["guserNameForWhereSQL0_"+strconv.Itoa(index)] = guser.Name
			whereSQL0.WriteString(" name = @guserNameForWhereSQL0_" + strconv.Itoa(index))
		}
		whereSQL0.WriteString(" ) ")
	} else {
		whereSQL0.WriteString(" name =\"guest\" ")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//Where("name=@name and age=@age")
func (p personDo) WhereFindByName(name string, col string, age int) (result *model.Person, err error) {
	params := map[string]interface{}{
		"name": name,
		"age":  age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("name=@name and age=@age")

	executeSQL := p.UnderlyingDB().Where(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//Where("name=@names and age=@ages")
func (p personDo) FindByNameAndAge(names []string, ages interface{}) (result []*model.Person, err error) {
	params := map[string]interface{}{
		"names": names,
		"ages":  ages,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("name=@names and age=@ages")

	executeSQL := p.UnderlyingDB().Where(generateSQL.String(), params).Find(&result)
	err = executeSQL.Error
	return
}

//sql("select id,name,age from @@table where age>18")
func (p personDo) FindBySimpleName() (result *model.Person, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select id,name,age from people where age>18")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select count(*) from @@table)
func (p personDo) GetCount() (result int, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select count(*) from people")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select Birthday from @@table {{where}} id=@id{{end}})
func (p personDo) GotBirthDay(id int) (result time.Time, err error) {
	params := map[string]interface{}{
		"id": id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select Birthday from people")
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id=@id")
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//sql(select * from @@table)
func (p personDo) GetMap1() (result map[string]interface{}) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")

	result = make(map[string]interface{})
	_ = p.UnderlyingDB().Raw(generateSQL.String()).Take(result)
	return
}

//sql(insert into @@table (name,age)values(@name,@age))
func (p personDo) InsertUser(name string, age int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"age":  age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("insert into people (name,age)values(@name,@age)")

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//sql(select * from @@table
//		{{if name=="admin"}}
//			{{where}}
//				id>0
//				{{if age>18}}
//					and age>18
//				{{end}}
//			{{end}}
//		{{else if name=="root"}}
//			{{where}}
//				id>10
//			{{end}}
//	{{else if name=="hello"}}
//			{{where}}
//				id>16
//			{{end}}
//		{{else}}
//			{{where}}
//				id>50
//			{{end}}
//			{{if name=="user"}}
//				and 1=1
//			{{end}}
//			and name = admin
//		{{end}}
//	)
func (p personDo) WhereInIF(name string, id int, age int) (result *model.Person, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	if name == "admin" {
		var whereSQL0 strings.Builder
		whereSQL0.WriteString(" id>0 ")
		if age > 18 {
			whereSQL0.WriteString(" and age>18 ")
		}
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)
	} else if name == "root" {
		var whereSQL1 strings.Builder
		whereSQL1.WriteString(" id>10 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL1)
	} else if name == "hello" {
		var whereSQL2 strings.Builder
		whereSQL2.WriteString(" id>16 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL2)
	} else {
		var whereSQL3 strings.Builder
		whereSQL3.WriteString(" id>50 ")
		helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL3)
		if name == "user" {
			generateSQL.WriteString(" and 1=1 ")
		}
		generateSQL.WriteString(" and name = admin ")
	}

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//sql(update @@table {{set}}{{if name!=""}}name=@name{{end}}{{end}}where id=@id)
func (p personDo) HasSet(name string, id int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"id":   id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("update people")
	var setSQL0 strings.Builder
	if name != "" {
		setSQL0.WriteString("name=@name")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	generateSQL.WriteString("where id=@id")

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//select * from @@table
//			{{if name=="aa{{where}}aa"}}
//				id=@id
//				{{if age>18 }}
//					and age=@age
//				{{else}}
//					and name="{{where}}name"
//				{{end}}
//				{{if name=="adm\nin"}}
//					and id>30
//				{{else if name=="sss"}}
//					and id>20
//				{{end}}
//			{{end}}
func (p personDo) RCE(name string, age int, id int) (result *model.Person) {
	params := map[string]interface{}{
		"id":  id,
		"age": age,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	if name == "aa{{where}}aa" {
		generateSQL.WriteString(" id=@id")
		if age > 18 {
			generateSQL.WriteString(" and age=@age")
		} else {
			generateSQL.WriteString(" and name=\"{{where}}name\" ")
		}
		if name == "adm\nin" {
			generateSQL.WriteString(" and id>30 ")
		} else if name == "sss" {
			generateSQL.WriteString(" and id>20 ")
		}
	}

	_ = p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	return
}

//update @@table
//	{{set}}
//		update_time=now(),
//		{{if name != ""}}
//			name=@name
//		{{end}}
//	{{end}}
//	{{where}}
//		id=@id
//	{{end}}
func (p personDo) UpdateName(name string, id int) (err error) {
	params := map[string]interface{}{
		"name": name,
		"id":   id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("update people")
	var setSQL0 strings.Builder
	setSQL0.WriteString(" update_time=now(), ")
	if name != "" {
		setSQL0.WriteString(" name=@name")
	}
	helper.JoinBuilder(&generateSQL, " SET ", setSQL0)
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id=@id")
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Exec(generateSQL.String(), params)
	err = executeSQL.Error
	return
}

//sql(select id,name,age from @@table where name="aaax
//
//		\"xxx" and age >18
//				{{if cond1}} and id=true  {{end}}
//				{{if name != ""}}
//				and @@column=@name{{end}}
//			)
func (p personDo) FindByIDOrName(cond1 bool, id int, column string, name string) (result *model.Person, err error) {
	params := map[string]interface{}{
		"name": name,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("\\\"xxx\" and age >18 ")
	if cond1 {
		generateSQL.WriteString(" and id=true ")
	}
	if name != "" {
		generateSQL.WriteString(" and " + p.Quote(column) + "=@name")
	}
	generateSQL.WriteString(" )")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table
//  {{where}}
//		  id>0
//       {{if cond}}id=@id {{end}}
//       {{   if value != ""}}or @@key=@value{{end}}
//   {{end}}
func (p personDo) FindByIDOrKey(cond bool, id int, key string, value string) (result *model.Person, err error) {
	params := map[string]interface{}{
		"id":    id,
		"value": value,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people")
	var whereSQL0 strings.Builder
	whereSQL0.WriteString(" id>0 ")
	if cond {
		whereSQL0.WriteString("id=@id")
	}
	if value != "" {
		whereSQL0.WriteString("or " + p.Quote(key) + "=@value")
	}
	helper.JoinBuilder(&generateSQL, " WHERE ", whereSQL0)

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

//select group_concat(name) from @@table
func (p personDo) FindNames() (result string, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select group_concat(name) from people")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String()).Take(&result)
	err = executeSQL.Error
	return
}

//select * from @@table where id>@id
func (p personDo) FindOne(id int) (result *model.Person, err error) {
	params := map[string]interface{}{
		"id": id,
	}

	var generateSQL strings.Builder
	generateSQL.WriteString("select * from people where id>@id")

	executeSQL := p.UnderlyingDB().Raw(generateSQL.String(), params).Take(&result)
	err = executeSQL.Error
	return
}

func (p personDo) Debug() *personDo {
	return p.withDO(p.DO.Debug())
}

func (p personDo) WithContext(ctx context.Context) *personDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p personDo) Clauses(conds ...clause.Expression) *personDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p personDo) Not(conds ...gen.Condition) *personDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p personDo) Or(conds ...gen.Condition) *personDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p personDo) Select(conds ...field.Expr) *personDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p personDo) Where(conds ...gen.Condition) *personDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p personDo) Order(conds ...field.Expr) *personDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p personDo) Distinct(cols ...field.Expr) *personDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p personDo) Omit(cols ...field.Expr) *personDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p personDo) Join(table schema.Tabler, on ...field.Expr) *personDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p personDo) LeftJoin(table schema.Tabler, on ...field.Expr) *personDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p personDo) RightJoin(table schema.Tabler, on ...field.Expr) *personDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p personDo) Group(cols ...field.Expr) *personDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p personDo) Having(conds ...gen.Condition) *personDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p personDo) Limit(limit int) *personDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p personDo) Offset(offset int) *personDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p personDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *personDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p personDo) Unscoped() *personDo {
	return p.withDO(p.DO.Unscoped())
}

func (p personDo) Create(values ...*model.Person) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p personDo) CreateInBatches(values []*model.Person, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p personDo) Save(values ...*model.Person) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p personDo) First() (*model.Person, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Person), nil
	}
}

func (p personDo) Take() (*model.Person, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Person), nil
	}
}

func (p personDo) Last() (*model.Person, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Person), nil
	}
}

func (p personDo) Find() ([]*model.Person, error) {
	result, err := p.DO.Find()
	return result.([]*model.Person), err
}

func (p personDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Person, err error) {
	buf := make([]*model.Person, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p personDo) FindInBatches(result *[]*model.Person, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p personDo) Attrs(attrs ...field.AssignExpr) *personDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p personDo) Assign(attrs ...field.AssignExpr) *personDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p personDo) Joins(field field.RelationField) *personDo {
	return p.withDO(p.DO.Joins(field))
}

func (p personDo) Preload(field field.RelationField) *personDo {
	return p.withDO(p.DO.Preload(field))
}

func (p personDo) FirstOrInit() (*model.Person, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Person), nil
	}
}

func (p personDo) FirstOrCreate() (*model.Person, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Person), nil
	}
}

func (p personDo) FindByPage(offset int, limit int) (result []*model.Person, count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	result, err = p.Offset(offset).Limit(limit).Find()
	return
}

func (p personDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p *personDo) withDO(do gen.Dao) *personDo {
	p.DO = *do.(*gen.DO)
	return p
}
